#include <instro/selectors/callpathselector.h>

#include <ostream>
#include <CallGraph.h>
#include <RoseSrc_CallGraphAnalysis.h>

using namespace InstRO;

/* "Private" functor */
/** \cond PRIVATE */
/** 
 * A Function object that checks if a given function is either included by rose or if it is generated by the compiler.
 * If one of these is the case, false is returned and the function is not included in the callgraph
 * \brief A Function object that determines which functions are to be represented in the call graph.
 */
struct keepFunction : public std::unary_function<bool,SgFunctionDeclaration*>{
public:
    /**
  * \brief The actual function determining if to include the given function in the callgraph
  * \param funcDecl The function declaration that is to be checked for inclusion in the callgraph
  * \return True iff the function is actually written by the user and not included by rose or generated by the compiler
  */
    bool operator()(SgFunctionDeclaration* funcDecl){
        ROSE_ASSERT(funcDecl != NULL);
        std::string filename = funcDecl->get_file_info()->get_filename();

        /* Filter out functions from the ROSE preinclude header file */
        if(filename.find("rose_edg_required_macros_and_functions")!=std::string::npos)
            return false;

        /* Filter out compiler generated functions */
        if(funcDecl->get_file_info()->isCompilerGenerated()==true)
            return false;

        return true;
    }
};
/** \endcond */

/* Public functions */
/* Overloaded constructor, if output of the callgraph is not needed */
CallpathSelector::CallpathSelector(SgProject* project, int maxDepth)
    :maxDepth(maxDepth){
    init(project, maxDepth, "");
}

/** 
 * \brief Constructor 
 * \param project The project to be traversed
 * \param maxDepth The maximal depth to which functions shall be instrumented
 * \param output The path to output the callgraph to. If this is empty, the callgraph is not printed
 * \return A List containing every node's distance to the mainnode
 */
CallpathSelector::CallpathSelector(SgProject* project, int maxDepth, std::string output)
    :maxDepth(maxDepth){
    init(project, maxDepth, output);
}


void CallpathSelector::init(SgProject* project, int maxDepth, std::string output){
    // Build the callGraph for the given function
    CallGraphBuilder* cgBuilder = new CallGraphBuilder(project);
    cgBuilder->buildCallGraph(keepFunction());
    SgIncidenceDirectedGraph* callGraph = cgBuilder->getGraph();

    /* Get the main-node in order to start there */
    SgGraphNode* mainNode = getMainFunctionNodeFromGraph(callGraph);

    /* Mark the main-node as visited */
    addEntry(getQualifiedName(mainNode), 0);

    /* Start traversal from main-node */
    breadthFirstSearch(callGraph, mainNode, 0);

    if(!output.empty()){
        printCallGraphScalasca(callGraph, maxDepth, output);
    }
}

/**
 * \brief Visiting function. Is called with every node in the AST and decides whether or not to instrument it 
 * \param node The currently visited node
 */
void CallpathSelector::visit(SgNode* node){
    if(isSgFunctionDefinition(node)){
        if(getDepth(isSgFunctionDefinition(node)->get_declaration()->get_qualified_name().getString()) <= maxDepth){
            this->select(node);
        } else {
            //			this->reject(node);
        }
    }
}

/**
 * \brief Returns the depth of a given functionName in the callGraph, starting from the mainnode
 * \param functionName The name of the function to be located in the callGraph
 * \return The distance between the mainnode an the function node with the given name
 */
int CallpathSelector::getDepth(const std::string functionName){
    /* Iterate through all contents of the calldepthlist, return true, if functionName is in it */
    for(std::list<entry>::iterator i = callDepthList.begin(); i != callDepthList.end(); i++){
        if(functionName == (*i).functionName){
            return (*i).callDepth;
        }
    }
    /* checked all elements of the callDepthList, name not found */
    return -1;
}

/**
 * \brief Checks is the given function name is present on the list at all
 * \param functionName The name of the function to be located in the callGraph
 * \return True iff a function with the given name is present in the callGraph
 */
bool CallpathSelector::isOnList(const std::string functionName){
    /* Since getDepth(std::string) returns -1 on error, we can use this function to find out, if the given function exists on the list */
    return (getDepth(functionName) != -1);
}

/**
 * \brief Removes a given entry from the list, if it is present in the first place
 * \param functionName The name of the function to be removed from the list
 */
void CallpathSelector::removeEntry(const std::string functionName){
    /* Iterate through all contents of the calldepthlist, erase it when found */
    for(std::list<entry>::iterator i = callDepthList.begin(); i != callDepthList.end(); i++){
        if(functionName == (*i).functionName){
            /* Found element, delete it from the list */
            callDepthList.erase(i);
        }
    }
}

/**
 * \brief Sets a new value for an entry, or creates it, if it was not yet present
 * \param functionName The name of the function to be updated
 * \param depth The new depth to be assigned to the function
 */
void CallpathSelector::updateEntry(const std::string functionName, int depth){
    if(isOnList(functionName)){
        /* Iterate through all contents of the calldepthlist, change depth when entry is found */
        for(std::list<entry>::iterator i = callDepthList.begin(); i != callDepthList.end(); i++){
            if(functionName == (*i).functionName){
                (*i).callDepth = depth;
            }
    	}
    }
    else {
        addEntry(functionName, depth);
    }
}

/* Private functions */

/**
 * \brief Adds a new entry. Does _not_ check if the entry is already present
 * \param functionName The name of the function to be added
 * \param depth The depth to be assigned to the function
 */
void CallpathSelector::addEntry(const std::string functionName, int depth){
    /* Make a new entry */
    entry newEntry;
    /* Add new contents to the entry */
    newEntry.functionName = functionName;
    newEntry.callDepth = depth;
    /* Add the new entry to the list */
    callDepthList.push_back(newEntry);
}

/**
 * \brief Conducts a BFS on the given graph. Does not take into consideration the nodes already present on the list
 * \param callGraph The callGraph to be analyzed
 * \param currentNode The node from which to start the BFS
 * \param currentDepth The starting depth. It is assumed, that currentNode is located at this depth
 */
void CallpathSelector::breadthFirstSearch(SgIncidenceDirectedGraph* callGraph, SgGraphNode* currentNode, int currentDepth){
    /* Get all children */
    std::set<SgGraphNode*> children = getChildren(callGraph, currentNode);

    /* Reserve space for all children to remember if to visit them */
    std::list<tovisit> visitingList;

    /* Initialise the list with the children of the current node */
    for(std::set<SgGraphNode*>::iterator i = children.begin(); i != children.end(); i++){
        tovisit newEntry;
        newEntry.node = *i;
        newEntry.visited = false;
        visitingList.push_back(newEntry);
    }

    /* Iterate over all children and assign them a depth or do not visit them later on, as they have already been visited */
    for(std::list<tovisit>::iterator i = visitingList.begin(); i != visitingList.end(); i++){
        /* Check if the node is already on the list. If this is not the case, it was not yet visited, so we add it to the list with the current depth */
        if(!isOnList(getQualifiedName((*i).node))){
            /* We do not need to explicitely remember to visit the node, since visited has been initialized with false */
            addEntry(getQualifiedName((*i).node), currentDepth + 1);
        }
        else {
            /* remember that the node has already been visited */
            (*i).visited = true;
        }
    }

    /* Iterate over all children once again and visit those which need to be visited */
    for(std::list<tovisit>::iterator i = visitingList.begin(); i != visitingList.end(); i++){
        if((*i).visited == false){
            breadthFirstSearch(callGraph, (*i).node, currentDepth + 1);
        }
    }
}

/**
 * \brief Looks for the node representing the main function and returns it 
 * \param callGraph The callgraph in which the node representing the mainfunction is to be located
 * \return The node from the graph which represents the mainfunction
 */
SgGraphNode* CallpathSelector::getMainFunctionNodeFromGraph(SgIncidenceDirectedGraph* callGraph){
    /* Declare the currentDeclaration here, so we do not have to declare it in every loop iteration */
    SgFunctionDeclaration* currentDeclaration = 0;

    /* Get all the nodes from the graph */
    std::set<SgGraphNode*> nodes = callGraph->computeNodeSet();

    for(std::set<SgGraphNode*>::iterator i = nodes.begin(); i != nodes.end(); i++){
        /* Cast currenty represented node to SgFunctionDeclaration explicitely, so the call to strcmp does not get too confusing */
        currentDeclaration = isSgFunctionDeclaration((*i)->get_SgNode());
        /* Use of hardcoded value is justified, since the main function is always named "::main" */
        if(strcmp(currentDeclaration->get_qualified_name().str(), "::main") == 0)
            return (*i);
    }
    /* No node representing the main function found, return 0 */
    return 0;
}

/**
 * \brief Returns all children of the given node as a set of nodes
 * \param callGraph The graph to be analyzed
 * \param parent The node whose children are to be returned
 * \return A set of all children of the given node in the given callgraph
 */
std::set<SgGraphNode*> CallpathSelector::getChildren(SgIncidenceDirectedGraph* callGraph, SgGraphNode* parent){
    /* Get all outgoing edges */
    std::set<SgDirectedGraphEdge*> outEdges = callGraph->computeEdgeSetOut(parent);

    /* Follow each edge and add its end to a set of children */
    std::set<SgGraphNode*> returnSet;

    for(std::set<SgDirectedGraphEdge*>::iterator i = outEdges.begin(); i != outEdges.end(); i++){
        returnSet.insert((*i)->get_to());
    }

    return returnSet;
}

/**
 * \brief Checks if the given node represents a functionDeclaration and returns its name, if this is the case.
 * \param node The node whose name is to be returned.
 * \return The name of the function represented by the given node, if the node is a functiondeclaration. Else an empty string is returned
 */
std::string CallpathSelector::getQualifiedName(SgGraphNode* node){
    /* Get the underlying functionDeclaration */
    SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node->get_SgNode());

    /* If the node represents something else than a functionDeclaration, abort */
    if(functionDeclaration == 0){
        return std::string();
    }

    /* Else return the name of the represented function */
    return functionDeclaration->get_qualified_name().getString();
}

/**
 * \brief Prints the given callgraph to the given depth in scalasca-compatible format.
 * \warning Be aware that this representation shows all possible routes, while scalasca only shows the one actually taken.
 * \param callGraph The callgraph to be printed.
 * \param maxDepth The maximal depth to which the callgraph has to be traversed. Has to be specified, since we want to roll out the graph in order to form a tree.
 * \param outputPath The path to the file into which the callGraph has to be printed
 */
void CallpathSelector::printCallGraphScalasca(SgIncidenceDirectedGraph* callGraph, unsigned int maxDepth, const std::string outputPath){
    /* At first we need to find the node representing the main-function */
    SgGraphNode* mainFunctionNode = getMainFunctionNodeFromGraph(callGraph);

    /* Now we open a stream to the output file */
    std::ofstream output(outputPath.c_str());

    /* Print the callGraph beginning at the main node to the given depth */
    printSubGraphScalasca(callGraph, mainFunctionNode, 0, maxDepth, &output);

    /* Close the file again */
    output.close();
}

/**
 * \brief Prints the subgraph beginning at root to depth maxDepth, assuming that root is located in depth currentDepth
 * \param callGraph The callgraph containing the given rootnode and its children.
 * \param root The starting point, from which the callGraph should be rolled out.
 * \param currentDepth Root's depth in the rolled out callgraph. Allows for recursive calling of this method.
 * \param maxDepth The maximal depth up to which the callgraph should be rolled out
 * \param output A handle for the output file. Does not get passed a path to the file in order to reduce load on the filesystem 
 * 	by keeping a single descriptor for the whole output instead of reopening the file for every node.
 */
void CallpathSelector::printSubGraphScalasca(SgIncidenceDirectedGraph* callGraph, SgGraphNode* root, int currentDepth, int maxDepth, std::ofstream* output){
    /* Abort if we have reached the maximal depth */
    if(currentDepth == maxDepth)
        return;

    /* We have not yet reached the maximal depth, tell the user which node we are in */
    printNodeScalasca(root, currentDepth, output);

    /* Since we want to do a DFS, we can simply iterate over all childs and continue in them with incremented depth */
    std::set<SgGraphNode*> children = getChildren(callGraph, root);

    /* Call this function recursively for every child of the given node with increased depth, thus rolling out the callgraph */
    for(std::set<SgGraphNode*>::iterator i = children.begin(); i != children.end(); i++){
        printSubGraphScalasca(callGraph, (*i), currentDepth+1, maxDepth, output);
    }
}

/** 
 * \brief Prints the given node with given depth, taking care of all necessary seperators for scalasca-compatibility.
 * \param node The node to be printed, supplies the function name.
 * \param currentDepth The depth the given node is located in. Is used for determining the number of delimiters and the indentationdepth
 * \param output A reference to the file the created line is to be written to
 */
void CallpathSelector::printNodeScalasca(SgGraphNode* node, int currentDepth, std::ofstream* output){
    /* Print the separators, first occurence of " |" in depth 2 */
    for(int i = 0; i < currentDepth-1; i++){
        *output << " |";
    }

    /* If we are deeper than level 0, also print  " + " */
    if(currentDepth > 0){
        *output << " + ";
    }

    /* To achieve greater scalasca-compatibility, truncate the first two characters of the qualified name, thus truncating the leading doublecolons */
    std::string nodeName = getQualifiedName(node);
    nodeName.erase(0, 2);	/* Erase two characters from the beginning of the string */

    /* Print the name of the function represented by the given node and start a new line */
    *output << nodeName << '\n';
}
