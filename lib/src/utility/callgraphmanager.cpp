#include "instro/utility/callgraphmanager.h"

#include <CallGraph.h>

// verbose output for debugging
#define VERBOSE 0

using namespace InstRO;

/* "Private" functor */
/** \cond PRIVATE */
/**
 * A Function object that checks if a given function is either included by rose or if it is generated by the compiler.
 * If one of these is the case, false is returned and the function is not included in the callgraph
 * \brief A Function object that determines which functions are to be represented in the call graph.
 */
//CI was here: struct keepFunction : public std::unary_function<bool,SgFunctionDeclaration*> {
struct keepFunction : public std::unary_function<bool,SgNode*> {
public:
	/**
  * \brief The actual function determining if to include the given function in the callgraph
  * \param funcDecl The function declaration that is to be checked for inclusion in the callgraph
  * \return True iff the function is actually written by the user and not included by rose or generated by the compiler
  */
	bool operator()(SgNode* node){
		SgFunctionDeclaration * funcDecl=isSgFunctionDeclaration(node);
		ROSE_ASSERT(funcDecl != NULL);
		std::string filename = funcDecl->get_file_info()->get_filename();

		/* Filter out functions from the ROSE preinclude header file */
		if(filename.find("rose_edg_required_macros_and_functions")!=std::string::npos)
			return false;

		/* Filter out compiler generated functions */
//		if(funcDecl->get_file_info()->isCompilerGenerated()==true)
//			return false;

		return true;
	}
};
/** \endcond */


/**
 * \brief This constructor obtains the call graph and the corresponding AST-to-CallGraph mapping
 * \param project The AST whose callGraph will be created
 */
CallGraphManager::CallGraphManager(SgProject* project, CalleeToCallerMap* callsByCaller) :
		callsByCaller(callsByCaller)	// not needed by all users
{
	// Build CallGraph
	CallGraphBuilder cgBuilder(project);
	cgBuilder.buildCallGraph(keepFunction());
	callGraph = cgBuilder.getGraph();

	// Get GraphNode Map
	nodeMap = cgBuilder.getGraphNodesMapping();

#if VERBOSE
	dumpCallGraphMapping(project);
#endif
}

/**
 * \brief Returns the corresponding node of the call graph, given a starting Statement in the AST
 * \param start The starting statement in the AST
 * \return The Node of the call graph that corresponds to the functionDefinition holding the starting Statement
 */
SgGraphNode* CallGraphManager::getCallGraphNode(SgFunctionDeclaration* start) {
	// we need the first non-defining declaration as a map key
	SgFunctionDeclaration* nondefDecl = ASTHelper::getFirstNondefDeclaration(start);

	if(nodeMap.find(nondefDecl) == nodeMap.end()) {
#if VERBOSE
		std::cout << "Key: " << nondefDecl << ": "
				<< nondefDecl->unparseToString() << " not found." << std::endl;
#endif
		return NULL;
	}
#if VERBOSE
		std::cout << "Key: " << nondefDecl << ": " << nondefDecl->unparseToString()
				<< " found: " << nodeMap.at(nondefDecl) << std::endl;
#endif
	return nodeMap.at(nondefDecl);
}

/**
 * \param node A Node of the Call Graph
 * \return The Function Declaration corresponding to the Graph Node
 */
SgFunctionDeclaration* CallGraphManager::getFunctionDeclaration(SgGraphNode* node) {
	return isSgFunctionDeclaration( node->get_SgNode() );
}

/**
 * \brief Returns all children of a call graph node recursively up to a certain level
 * \param parent the starting node in the call graph
 * \param remainingDepth the amount of levels of children that are considered starting from parent
 * \return The Node of the call graph that corresponds to the functionDefinition holding the starting Statement
 */
std::set<SgGraphNode*> CallGraphManager::getDescendantsTillDepth(SgGraphNode* parent, int remainingDepth) {
	std::set<SgGraphNode*> descendants;

	if(remainingDepth>0) {

		descendants = getChildrenSet(parent);
		std::set<SgGraphNode*> allGrandChildren;

		// recursive traversal of direct children
		for(std::set<SgGraphNode*>::iterator it=descendants.begin(); it!=descendants.end(); it++) {
			// recursive collect grand children and deeper
			// RN XXX This is a bit ugly
			std::set<SgGraphNode*> grandChildren = getDescendantsTillDepth(*it, remainingDepth-1);
			allGrandChildren.insert(grandChildren.begin(), grandChildren.end());
		}
		// insert all
		descendants.insert(allGrandChildren.begin(), allGrandChildren.end());
	}

	return descendants;
}

/**
 * \brief Determines the approximate number of calls for a function via Call Graph
 * \param callee The declaration of a function
 * \return The approximate number of calls of a function
 */
long long CallGraphManager::approximateNumberOfCalls(SgFunctionDeclaration* callee) {
#if VERBOSE > 4
	std::cout << "Entering: " << __FUNCTION__ << " : " << callee << std::endl;
#endif
	inProgress.insert(callee);

	// get direct children
	std::set<SgGraphNode*> parents;
	parents = getParentSet(getCallGraphNode(callee));

	// calculate frequency for all predecessors
	std::set<SgGraphNode*>::iterator it;
	for(it=parents.begin();it!=parents.end();it++) {
		SgFunctionDeclaration* callerDecl = getFunctionDeclaration(*it);

		if(inProgress.find(callerDecl)!=inProgress.end()) {
			// circle detected
			boost::unordered_set<SgFunctionDeclaration*>::iterator itSet;
			for(itSet=inProgress.begin(); itSet!=inProgress.end(); itSet++) {
				nodeMultiplier[*itSet] = INT_MAX;	// XXX arbitrarily chosen
			}
			continue;
		}

		// stop recursion if node is already known
		if(nodeMultiplier.find(callerDecl)!=nodeMultiplier.end()) {
			inProgress.erase(callerDecl);
			continue;
		}

		approximateNumberOfCalls(callerDecl);	//recursion
	}

	// if it has no predecessors it is called exactly once
	if(parents.size()==0) {
		inProgress.erase(callee);
		nodeMultiplier[callee] = 1L;
		return 1L;
	}

	// all predecessors have been calculated, handle current node
	long long overallSum = 0L;
	for(it=parents.begin();it!=parents.end();it++) {

		// #calls = #calls + #call(callee)*#calls(caller)
		SgFunctionDeclaration* callerDecl = getFunctionDeclaration(*it);
		long long multiplier = nodeMultiplier[callerDecl];
		long long callsOfCurrentNode = (*callsByCaller)[callee][callerDecl];
		overallSum += (callsOfCurrentNode * multiplier);

	}
	inProgress.erase(callee);
	// save the result so other nodes don't calculate it again
	nodeMultiplier[callee] = overallSum;
	return overallSum;
}

/**
 * \brief Returns all direct children of the given node in the callGraph
 * \param parent The node whose children are returned
 * \return A set of all children of the given node in the callGraph
 */
std::set<SgGraphNode*> CallGraphManager::getChildrenSet(SgGraphNode* parent){

	std::vector<SgGraphNode*> childVec;
	callGraph->SgIncidenceDirectedGraph::getSuccessors(parent, childVec);

	std::set<SgGraphNode*> children;
	children.insert(childVec.begin(), childVec.end());

#if VERBOSE
	std::cout << "Call graph parent:: " << parent->get_SgNode()->unparseToString() << std::endl;
	for(std::vector<SgGraphNode*>::iterator it=childVec.begin(); it!=childVec.end(); it++) {
		std::cout << "\tFound child: " << (*it)->get_SgNode()->unparseToString() << std::endl;
	}
#endif

	return children;
}

/**
 * \brief Returns all parents of a call graph node recursively up to a certain level
 * \param child the starting node in the call graph
 * \param remainingDepth the amount of levels of children that are considered starting from child
 * \return The Node of the call graph that corresponds to the functionDefinition holding the starting Statement
 */
std::set<SgGraphNode*> CallGraphManager::getAncestorsTillDepth(SgGraphNode* child, int remainingDepth) {

	std::set<SgGraphNode*> ancestors;

	if(remainingDepth>0) {

		ancestors = getParentSet(child);
		std::set<SgGraphNode*> allGrandParents;

		// recursive traversal of parents
		for(std::set<SgGraphNode*>::iterator it=ancestors.begin(); it!=ancestors.end(); it++) {
			// recursively collect grand parents and higher
			// RN XXX This is a bit ugly (also code duplicaton)
			std::set<SgGraphNode*> grandParents = getAncestorsTillDepth(*it, remainingDepth-1);
			allGrandParents.insert(grandParents.begin(), grandParents.end());
		}
		ancestors.insert(allGrandParents.begin(), allGrandParents.end());
	}

	return ancestors;
}

/**
 * \brief Returns all direct parents of the given node in the callGraph
 * \param child The node whose parents are returned
 * \return A set of all parents of the given node in the callGraph
 */
std::set<SgGraphNode*> CallGraphManager::getParentSet(SgGraphNode* child){

	if(child == NULL){
		std::cerr << "ERROR in " << __FUNCTION__ << " : child was NULL" << std::endl;
		return std::set<SgGraphNode*>();
	}

	std::vector<SgGraphNode*> parentVec;
	callGraph->SgIncidenceDirectedGraph::getPredecessors(child, parentVec);

	std::set<SgGraphNode*> parents;
	parents.insert(parentVec.begin(), parentVec.end());

#if VERBOSE
	std::cout << "Call graph child: " << child->get_SgNode()->unparseToString() << std::endl;
	for(std::vector<SgGraphNode*>::iterator it=parentVec.begin(); it!=parentVec.end(); it++) {
		std::cout << "\tFound parent: " << (*it)->get_SgNode()->unparseToString() << std::endl;
	}
#endif

	return parents;
}

/**
 * \brief Dump the mapping from function declarations to call graph nodes to stdout
 * \param
 */
void CallGraphManager::dumpCallGraphMapping(bool keysOnly) {
	std::cout << std::endl << "Dumping node map with " << nodeMap.size() << " keys: " << std::endl;

	typedef boost::unordered_map<SgFunctionDeclaration*, SgGraphNode*>::iterator MapIt;
	for(MapIt it=nodeMap.begin(); it!=nodeMap.end(); it++) {
		std::cout << (*it).first << ": " << (*it).first->unparseToString() << std::endl;
		if(!keysOnly) {
			std::cout << " -->\t" << (*it).second << ": " << (*it).second->get_name() << std::endl;
		}
	}
	std::cout << std::endl;
}


int CallGraphManager::getNumberOfIncomingEdges(SgGraphNode* node){
	if(node == NULL)
		return -1;

	return callGraph->computeEdgeSetIn(node).size();
}

int CallGraphManager::getNumberOfOutgoingEdges(SgGraphNode* node){
	if(node == NULL)
		return -1;

	return callGraph->computeEdgeSetOut(node).size();

}


