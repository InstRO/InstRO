#ifndef INSTRO_CORE_PASSIMPLEMENTATION_H
#define INSTRO_CORE_PASSIMPLEMENTATION_H

#include <initializer_list>
#include <unordered_map>

#include "instro/core/ConstructSet.h"
#include "instro/utility/MemoryManagement.h"
#include "instro/core/ChannelConfiguration.h"

#include <cassert>

namespace InstRO {
// We need a forward declaration of Pass, since Pass and PassImplementation are circular
class Pass;

namespace Core {
/*
 * This class is the user-interface to create his own pass.
 * One needs to inherit from this class and implement a compiler dependent pass.
 * Using the getInput(passId) one can retrieve the ConstructSet of one of the
 * predecessors.
 */
class PassImplementation {
	friend class InstRO::Pass;

 public:
	/** Since the Pass Implementation no longer knows of this ChannelConfiguration object, it can now be default
	 * constructed */
	PassImplementation() {}
	virtual ~PassImplementation() {}

	virtual void init() {}	// provide default impl because this is the default case
	virtual void execute() = 0;
	virtual void finalize() {}	// provide default impl because this is the default case

	void releaseOutput() { outputSet.clear(); }

	/** returns the ConstructSet generated by this pass */
	ConstructSet *getOutput() { return &outputSet; };

	/** returns a set of constructs, which haven been altered by this pass */
	const ConstructSet *cgetCollisionSet() { return &collisionSet; };

	//	const ChannelConfiguration &getChannelConfig() { return channelConfig; }

 protected:
	// The generated set of constructs the entity selected
	ConstructSet outputSet;

	// This set is used to track alterations to the AST and notify which nodes have been invalidated
	ConstructSet collisionSet;

	// Accessor method for the ConstructSet retrieved from input channel (counting from 0)
	const ConstructSet *getInput(int channel);

	ConstructSet *getCollisionSet() { return &collisionSet; }

 private:
	Pass *managingPass;
};

}	// namespace Core
}	// namespace InstRO

#endif
